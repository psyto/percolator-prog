No-options plan (apply in this order)

1) Delete the unsound transmute CPI helper

Your zc::invoke_signed_trade() still does transmute(info.clone()). That’s UB. Remove it.
	•	Delete everything in zc after engine_write (the invoke_signed_trade helper and its imports).
	•	In processor::TradeCpi, call invoke_signed directly.

Replacement pattern (exactly this shape):
	•	Construct a_lp_pda (your synthetic signer AccountInfo) as you already do.
	•	Call:

let infos: [&AccountInfo; 3] = [a_slab, &a_lp_pda, a_matcher_ctx];
invoke_signed(&ix, &infos, &[seeds])?;

No cloning-transmute. No “local” conversions.

⸻

2) Make TradeCpi strictly 7 accounts everywhere

Your on-chain TradeCpi handler is now 7 accounts (good). Your unit tests are still passing 8 accounts (they include lp_pda_acc).

Do this now:
	•	Update unit tests to call TradeCpi with exactly:
0. user (signer)
	1.	lp_owner (signer)
	2.	slab (writable)
	3.	clock
	4.	oracle (must equal config.index_oracle)
	5.	matcher_program (executable)
	6.	matcher_ctx (writable, owner == matcher_program key, data_len >= MATCHER_CONTEXT_LEN)

Delete from tests:
	•	All lp_pda_acc creation
	•	Any accounts[7] in TradeCpi tests
	•	Any “wrong lp_pda” unit tests (those become integration-only, because the PDA never comes in via accounts anymore).

⸻

3) Stop using matcher_ctx as “random system-owned”

You now correctly require:

if a_matcher_ctx.owner != a_matcher_prog.key { IllegalOwner }
if !a_matcher_prog.executable { InvalidAccountData }

So in tests, you must set:
	•	matcher_program.executable = true
	•	matcher_ctx.owner = matcher_program.key
	•	matcher_ctx.is_writable = true
	•	matcher_ctx.data = vec![0; MATCHER_CONTEXT_LEN]

Do that in every unit test that touches TradeCpi.

⸻

4) Zero the ABI prefix before CPI

You already defined a stable return ABI (first 64 bytes). Enforce freshness.

In TradeCpi, right before invoke_signed:

{
    let mut ctx = a_matcher_ctx.try_borrow_mut_data()?;
    ctx[..crate::constants::MATCHER_CONTEXT_PREFIX_LEN].fill(0);
}

This prevents “stale success” where a previous return passes validation without the matcher actually running.

⸻

5) Add and enforce req_id (no more “optional”)

You have req_id in the return struct but you’re not using it yet.

Do this now:
	1.	Compute a deterministic req_id in TradeCpi:
	•	simplest: xor-mix of (lp_account_id, oracle_price_e6, size as u64-lo/hi, clock.slot)
	2.	Write req_id into ctx prefix before CPI (same try_borrow_mut_data block as the zero):
	•	bytes [32..40] (matches your ABI struct).
	3.	Require matcher to echo it:
	•	Extend validate_matcher_return(...) to take req_id and check ret.req_id == req_id.

This makes “ABI return” not just a blob but a request/response pair.

⸻

6) Lock down the CPI call ABI (67 bytes)

Your call data is 67 bytes; keep it frozen.
	•	Add constants:
	•	MATCHER_CALL_TAG: u8 = 0
	•	MATCHER_CALL_LEN: usize = 67
	•	In TradeCpi:
	•	assert cpi_data.len() == MATCHER_CALL_LEN (debug_assert is fine)
	•	In matcher mock (integration test program):
	•	enforce len == 67, tag == 0, slab pk matches, etc.

⸻

7) Move all CPI-success testing into tests/integration.rs

Unit tests cannot exercise real CPI. They should only test:
	•	account validation,
	•	ABI parsing/validation,
	•	rejection paths.

Do this now:
	•	Delete/relax your unit test test_trade_cpi_pda_derivation “success-ish” logic.
	•	Replace with pure tests:
	•	wrong lp_owner signer → EngineUnauthorized
	•	wrong oracle key → InvalidArgument
	•	matcher not executable → InvalidAccountData
	•	ctx owner mismatch → IllegalOwner
	•	ctx too small → InvalidAccountData
	•	ABI flags invalid → InvalidAccountData
	•	ABI reserved nonzero → InvalidAccountData
	•	exec_price_e6 == 0 → InvalidAccountData
	•	exec_size violates bounds → InvalidAccountData

Then implement actual CPI behavior in tests/integration.rs using solana-program-test + your matcher mock program writing the prefix.

⸻

8) Integration tests: make them prove something real

In integration:
	1.	InitMarket
	2.	InitUser + Deposit collateral
	3.	InitLP + Deposit collateral
	4.	Crank if needed
	5.	TradeCpi with non-zero size
	6.	Assert:
	•	matcher ctx prefix written with expected oracle price, exec price, exec size, flags, echoed req_id
	•	engine state changed (position/capital), not just “ctx updated”

⸻

Your current code has 2 blocking issues to fix immediately
	1.	zc::invoke_signed_trade is UB (must be removed).
	2.	Unit tests still pass an 8th account to TradeCpi (must be removed and rewritten to 7-account shape).

Do those two first; everything else stacks cleanly after.

If you paste your current tests/integration.rs after you update TradeCpi to 7 accounts and remove the UB helper, I’ll rewrite the matcher mock to fill the full 64-byte prefix (version/flags/exec_price/exec_size/req_id/lp_account_id/oracle_price/reserved) and add the asserts that engine state actually changes.